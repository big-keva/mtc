<html>
<head>
	<meta http-equiv=Content-Type content="text/html; charset=utf-8">
	<meta name='description' content='zmap - ассоциативный массив C++ с произвольной сериализацией и поддержкой json'>
	<meta name='keywords' content='zmap, ассоциативный массив, с++ json, сериализация'>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>Ассоциативный массив zmap</title>
</head>
<style>
  div.caption {
	font-weight: bold;
	font-size: 150%;
	text-align: center;
	border-bottom: 1px solid #aaa;
	padding-bottom: .5em;
  }

  div.article
  {
    counter-reset: chapter;
    text-align: justify;
  	padding-left: 1em;
  }
  .article h1:before
  {
    content: counter(chapter) "." " ";
    counter-increment: chapter;
    font-size: 130%;
  }
  .article h1
  {
    counter-reset: section;
    font-size: 130%;
  }
  .article h2:before
  {
    content: counter(chapter)"."counter(section) ". ";
    counter-increment: section;
    font-size: 120%;
  }
  .article h2
  {
    counter-reset: level3;
    font-size: 120%;
  }
  .article h3:before
  {
    content: counter(chapter)"."counter(section)"."counter(level3)". ";
    counter-increment: level3;
    font-size: 110%;
  }
  .article h3
  {
    font-size: 110%;
  }

  ul.methods {
    list-style-type: none;
  }
  .methods li {
    font-weight: normal;
    font-family: monospace;
    white-space: pre;
  }

  div.example {
    font-weight: bold;
    font-family: monospace;
    white-space: pre;
    border: 1px solid #aaa;
    background-color: #eee;
  }

  div.description {
    font-size: 97%;
    white-space: pre;
  }

</style>
<body>

<div class='caption'>Ассоциативный массив zmap</div>

<div class='article'>
<h1>Абстрактная переменная zval</h1>
  <h2>Конструкторы</h2>
    <ol class='methods'>
	<li>zval()</li>
	<li>zval( const zval& ), zval( zval&& )</li>
	<li>zval( <i>ordinal_type</i> )</li>
	<li>zval( const char*, size_t = (size_t)-1 )</li>
	<li>zval( const widechar*, size_t = (size_t)-1 )</li>
	<li>zval( const charstr& ), zval( charstr&& )</li>
	<li>zval( const widestr& ), zval( widestr&& )</li>
	<li>zval( const uuid& ), zval( uuid&& )</li>
	<li>zval( const zmap& ), zval( zmap&& )</li>
	<li>zval( const array_char& ), zval( array_char&& )</li>
	<li>zval( const array_byte& ), zval( array_byte&& )</li>
	<li>zval( const array_int16& ), zval( array_int16&& )</li>
	<li>zval( const array_int32& ), zval( array_int32&& )</li>
	<li>zval( const array_int64& ), zval( array_int64&& )</li>
	<li>zval( const array_word16& ), zval( array_word16&& )</li>
	<li>zval( const array_word32& ), zval( array_word32&& )</li>
	<li>zval( const array_word64& ), zval( array_word64&& )</li>
	<li>zval( const array_float& ), zval( array_float&& )</li>
	<li>zval( const array_double& ), zval( array_double&& )</li>
	<li>zval( const array_charstr& ), zval( array_charstr& )</li>
	<li>zval( const array_widestr& ), zval( array_widestr& )</li>
	<li>zval( const array_uuid& ), zval( array_uuid&& )</li>
	<li>zval( const array_zval& ), zval( array_zval&& )</li>
	<li>zval( const array_zmap& ), zval( array_zmap&& )</li>
    </ol>
    <div class='description'>
	1) конструктор без параметров, формирует неинициализированное значение;
	2) копирование и перемещение;
	3 - 12) инициализация стандартными числовыми типами;
	13, 14) инициализация строками C-стиля, с указанием длины и без него;
	15, 16) инициализация C++-строками, копированием и перемещением;
	17) инициализация значением uuid;
	18) инициализация значением zmap;
	19 - 33) инициализация массивами, копированием и присваиванием.
    </div>

  <h2>Операторы присваивания</h2>
    <ol class='methods'>
	<li>zval& operator = ( const zval& ), zval( zval&& )</li>
	<li>zval& operator = ( char )</li>
	<li>zval& operator = ( uint8_t )</li>
	<li>zval& operator = ( int16_t )</li>
	<li>zval& operator = ( int32_t )</li>
	<li>zval& operator = ( int64_t )</li>
	<li>zval& operator = ( word16_t )</li>
	<li>zval& operator = ( word32_t )</li>
	<li>zval& operator = ( word64_t )</li>
	<li>zval& operator = ( float )</li>
	<li>zval& operator = ( double )</li>
	<li>zval& operator = ( const char*, size_t = (size_t)-1 )</li>
	<li>zval& operator = ( const widechar*, size_t = (size_t)-1 )</li>
	<li>zval& operator = ( const charstr& ), zval( charstr&& )</li>
	<li>zval& operator = ( const widestr& ), zval( widestr&& )</li>
	<li>zval& operator = ( const uuid& ), zval( uuid&& )</li>
	<li>zval& operator = ( const zmap& ), zval( zmap&& )</li>
	<li>zval& operator = ( const array_char& ), zval( array_char&& )</li>
	<li>zval& operator = ( const array_byte& ), zval( array_byte&& )</li>
	<li>zval& operator = ( const array_int16& ), zval( array_int16&& )</li>
	<li>zval& operator = ( const array_int32& ), zval( array_int32&& )</li>
	<li>zval& operator = ( const array_int64& ), zval( array_int64&& )</li>
	<li>zval& operator = ( const array_word16& ), zval( array_word16&& )</li>
	<li>zval& operator = ( const array_word32& ), zval( array_word32&& )</li>
	<li>zval& operator = ( const array_word64& ), zval( array_word64&& )</li>
	<li>zval& operator = ( const array_float& ), zval( array_float&& )</li>
	<li>zval& operator = ( const array_double& ), zval( array_double&& )</li>
	<li>zval& operator = ( const array_charstr& ), zval( array_charstr& )</li>
	<li>zval& operator = ( const array_widestr& ), zval( array_widestr& )</li>
	<li>zval& operator = ( const array_uuid& ), zval( array_uuid&& )</li>
	<li>zval& operator = ( const array_zval& ), zval( array_zval&& )</li>
	<li>zval& operator = ( const array_zmap& ), zval( array_zmap&& )</li>
    </ol>
    <div class='description'>
	1) копирование и перемещение zval;

	Присваивание:
	2-11) численного значения;
	12, 13) строки C-стиля, с указанием длины или без него;
	14, 15) строки C++, копированием и перемещением;
	16) uuid, копированием и перемещением;
	17) zmap, копированием и перемещением;
	18-32) массивов значений.
    </div>

  <h2>Доступ</h2>
	<h3>Стандартные типы</h3>
    <ol class='methods'>
	<li>const char*      get_char() const</li>
	<li>const uint08_t*  get_byte() const</li>
	<li>const int16_t*   get_int16() const</li>
	<li>const int32_t*   get_int32() const</li>
	<li>const int64_t*   get_int64() const</li>
	<li>const uint16_t*  get_word16() const</li>
	<li>const uint32_t*  get_word32() const</li>
	<li>const uint64_t*  get_word64() const</li>
	<li>const float*     get_float() const</li>
	<li>const double*    get_double() const</li>
	<li>char*            get_char()</li>
	<li>uint08_t*        get_byte()</li>
	<li>int16_t*         get_int16()</li>
	<li>int32_t*         get_int32()</li>
	<li>int64_t*         get_int64()</li>
	<li>uint16_t*        get_word16()</li>
	<li>uint32_t*        get_word32()</li>
	<li>uint64_t*        get_word64()</li>
	<li>float*           get_float()</li>
	<li>double*          get_double()</li>
	<li>char*            set_char( char = char() )</li>
	<li>uint08_t*        set_byte( uint8_t = uint8_t() )</li>
	<li>int16_t*         set_int16( int16_t = int16_t() )</li>
	<li>int32_t*         set_int32( int32_t = int32_t() )</li>
	<li>int64_t*         set_int64( int64_t = int64_t() )</li>
	<li>uint16_t*        set_word16( uint16_t = uint16_t() )</li>
	<li>uint32_t*        set_word32( uint32_t = uint32_t() )</li>
	<li>uint64_t*        set_word64( uint64_t = uint64_t() )</li>
	<li>float*           set_float( float = float() )</li>
	<li>double*          set_double( double = double() )</li>
	</ol>

	<h3>Строки</h3>
    <ol class='methods'>
	<li>const charstr* get_charstr() const</li>
	<li>const widestr* get_widestr() const</li>
	<li>charstr*       get_charstr()</li>
	<li>widestr*       get_widestr()</li>
	<li>charstr*       set_charstr()
                       ( charstr&& )
                       ( const charstr& )
                       ( const char*, size_t cch = -1 )</li>
	<li>widestr*       set_widestr()
                       ( widestr&& )
                       ( const widestr& )
                       ( const widechar*, size_t cch = -1 )</li>
	</ol>

	<h3>Специальные значения</h3>
    <ol class='methods'>
	<li>const uuid*    get_uuid() const</li>
	<li>const zmap*    get_zmap() [const]</li>
	<li>uuid*          get_uuid()</li>
	<li>zmap*          get_zmap()</li>
	<li>uuid*          set_uuid()
                       ( uuid&& )
                       ( const uuid& )</li>
	<li>zmap*          set_zmap()
                       ( zmap&& )
                       ( const zmap& )</li>
	</ol>

	<h3>Массивы</h3>
    <ol class='methods'>
	<li>const array_char*  get_array_char() const</li>
	<li>const array_byte*  get_array_byte() const</li>
	<li>const array_int16* get_array_int16() const</li>
	<li>const array_int32* get_array_int32() const</li>
	<li>const array_int64* get_array_int64() const</li>
	<li>const array_word16*  get_array_word16() const</li>
	<li>const array_word32*  get_array_word32() const</li>
	<li>const array_word64*  get_array_word64() const</li>
	<li>const array_float*   get_array_float() const</li>
	<li>const array_double*  get_array_double() const</li>
	<li>const array_charstr* get_array_charstr() const</li>
	<li>const array_widestr* get_array_widestr() const</li>
	<li>const array_uuid*  get_array_uuid() const</li>
	<li>const array_zval*  get_array_zval() const</li>
	<li>const array_zmap*  get_array_zmap() const</li>
	<li>const array_char*  get_array_char() const</li>
	<li>const array_byte*  get_array_byte() const</li>
	<li>const array_int16* get_array_int16() const</li>
	<li>const array_int32* get_array_int32() const</li>
	<li>const array_int64* get_array_int64() const</li>
	<li>const array_word16*  get_array_word16() const</li>
	<li>const array_word32*  get_array_word32() const</li>
	<li>const array_word64*  get_array_word64() const</li>
	<li>const array_float*   get_array_float() const</li>
	<li>const array_double*  get_array_double() const</li>
	<li>const array_charstr* get_array_charstr() const</li>
	<li>const array_widestr* get_array_widestr() const</li>
	<li>const array_uuid*  get_array_uuid() const</li>
	<li>const array_zval*  get_array_zval() const</li>
	<li>const array_zmap*  get_array_zmap() const</li>

	<li>array_char* set_array_char()
                  ( array_char&& )
                  ( const array_char& )</li>
	<li>array_byte* set_array_byte()
                  ( array_byte&& )
                  ( const array_byte& )</li>
	<li>array_int16*  set_array_int16()
                  ( array_int16&& )
                  ( const array_int16& )</li>
	<li>array_int32*  set_array_int32()
                  ( array_int32&& )
                  ( const array_int32& )</li>
	<li>array_int64*  set_array_int64()
                  ( array_int64&& )
                  ( const array_int64& )</li>
	<li>array_word16* set_array_word16()
                  ( array_word16&& )
                  ( const array_word16& )</li>
	<li>array_word32* set_array_word32()
                  ( array_word32&& )
                  ( const array_word32& )</li>
	<li>array_word64* set_array_word64()
                  ( array_word64&& )
                  ( const array_word64& )</li>
	<li>array_float*  set_array_float()
                  ( array_float&& )
                  ( const array_float& )</li>
	<li>array_double* set_array_double()
                  ( array_double&& )
                  ( const array_double& )</li>
	<li>array_charstr*  set_array_charstr()
                  ( array_charstr&& )
                  ( const array_charstr& )</li>
	<li>array_widestr*  set_array_widestr()
                  ( array_widestr&& )
                  ( const array_widestr& )</li>
	<li>array_uuid* set_array_uuid()
                  ( array_uuid&& )
                  ( const array_uuid& )</li>
	<li>array_zval* set_array_zval()
                  ( array_zval&& )
                  ( const array_zval& )</li>
	<li>array_zmap* set_array_zmap()
                  ( array_zmap&& )
                  ( const array_zmap& )</li>
	</ol>

  <h2>Прямое сравнение</h2>
    <ol class='methods'>
	<li>int   compare( const zval& ) const</li>
	<li>bool  operator == ( const zval& ) const</li>
	<li>bool  operator <  ( const zval& ) const</li>
	<li>bool  operator != ( const zval& ) const</li>
    </ol>

  <h2>Сравнение значений</h2>
    <ol class='methods'>
	<li>auto  CompTo( const zval& ) const -> unsigned;</li>
	<li>bool  lt( const zval& ) const</li>
	<li>bool  gt( const zval& ) const</li>
	<li>bool  eq( const zval& ) const</li>
	<li>bool  le( const zval& ) const</li>
	<li>bool  ge( const zval& ) const</li>
	<li>bool  ne( const zval& ) const</li>
    </ol>

  <h2>Арифметические операции</h2>
    <ol class='methods'>
	<li>zval  operator * ( const zval& ) const</li>
	<li>zval  operator / ( const zval& ) const</li>
	<li>zval  operator % ( const zval& ) const</li>
	<li>zval  operator + ( const zval& ) const</li>
	<li>zval  operator - ( const zval& ) const</li>
	<li>zval  operator << ( const zval& ) const</li>
	<li>zval  operator >> ( const zval& ) const</li>
	<li>zval  operator & ( const zval& ) const</li>
	<li>zval  operator ^ ( const zval& ) const</li>
	<li>zval  operator | ( const zval& ) const</li>
	<li>zval  operator ~ ()  const            </li>
    </ol>

  <h2>Вспомогательные методы</h2>
    <ol class='methods'>
	<li>bool  empty() const</li>
	<li>auto  clear() -> zval&</li>
	<li>auto  get_type() const -> unsigned</li>
	<li>auto  is_array() const -> bool</li>
	<li>auto  is_numeric() const -> bool</li>
    </ol>

  <h2>Сериализация</h2>
    <ol class='methods'>
	<li>size_t  GetBufLen(    ) const</li>
	<li>template &lt;class O&gt;<br>O* Serialize( O* ) const</li>
	<li>template &lt;class S&gt;<br>S* FetchFrom( S* )</li>
	<li>template &lt;class S&gt; static<br>S* SkipToEnd( S* )</li>
    </ol>

<h1>Ассоциативный массив zmap</h1>
</div>
<!--
/*

  typedef zval<>  zval;
  typedef zmap<>  zmap;

  struct zmap_exception
  {
    zmap_exception( int err, const char* msg = nullptr, const char* szfile = nullptr, int lineid = 0 ):
      nerror( err ), message( msg ), file( szfile ), line( lineid ) {}

  protected:  // variables
    int         nerror;
    const char* message;
    const char* file;
    int         line;
  };

  /*
    zval handles any data in local buffer; data may be accessed by accessor methods
  */
  template <class M>
  class zval
  {
    unsigned char vxtype;
    char          chdata[sizeof(array<char, M>)];

  public:     // untyped constant
    enum {  undefined_type = 0xff  };

public:     // set_?? methods
/* ordinal types */
  # define  derive_set( _type_ )                                                                  \
    _type_##_t* set_##_type_( _type_##_t v = 0 )                                                  \
      {  delete_data();  vxtype = z_##_type_;  return new( (_type_##_t*)&chdata ) _type_##_t( v );  }

      derive_set( char )
      derive_set( byte )
      derive_set( int16 )
      derive_set( word16 )
      derive_set( int32 )
      derive_set( word32 )
      derive_set( int64 )
      derive_set( word64 )
      derive_set( float )
      derive_set( double )
  # undef derive_set

/* regular strings  */
    char*     set_charstr( const char*  pszstr, unsigned  cchstr = (unsigned)-1 )
      {
        if ( cchstr == (unsigned)-1 )
          cchstr = pszstr != nullptr ? (unsigned)w_strlen( pszstr ) : 0;

        if ( cchstr == (unsigned)-1 )
          cchstr = pszstr != nullptr ? (unsigned)w_strlen( pszstr ) : 0;
        delete_data();

        if ( (*(char**)&chdata = (char*)M().alloc( cchstr + 1 )) == nullptr )
          return nullptr;

        if ( pszstr != nullptr )
          memcpy( *(char**)&chdata, pszstr, cchstr );

        (*(char**)&chdata)[cchstr] = '\0';
          vxtype = z_charstr;

        return *(char**)&chdata;
      }
    widechar* set_widestr( const widechar*  pszstr, unsigned  cchstr = (unsigned)-1 )
      {
        if ( cchstr == (unsigned)-1 )
          cchstr = pszstr != nullptr ? (unsigned)w_strlen( pszstr ) : 0;

        delete_data();

        if ( (*(widechar**)&chdata = (widechar*)M().alloc( sizeof(widechar) * (cchstr + 1) )) == nullptr )
          return nullptr;

        if ( pszstr != nullptr )
          memcpy( *(widechar**)&chdata, pszstr, sizeof(widechar) * cchstr );

        (*(widechar**)&chdata)[cchstr] = 0;
          vxtype = z_widestr;

        return *(widechar**)&chdata;
      }
    char*&  set_charstr()
      {  delete_data();  vxtype = z_charstr;  return *(char**)&chdata = nullptr;  }
    widechar*&  set_widestr()
      {  delete_data();  vxtype = z_widestr;  return *(widechar**)&chdata = nullptr;  }

/* special types: buffer, zmap and array(s) */
    zmap<M>*  set_zmap( const zmap<M>& z = zmap<M>() )
      {  delete_data();  vxtype = z_zmap;  return new( (zmap<M>*)&chdata ) zmap<M>( z );  }

/*
  set_array_#() macrogeneration
*/
  # define  derive_set_array( _type_ )                                        \
    array<_type_##_t, M>*  set_array_##_type_()                               \
    {                                                                         \
      delete_data();  vxtype = z_array_##_type_;                              \
      return new( (array<_type_##_t, M>*)&chdata ) array<_type_##_t, M>();    \
    }
    derive_set_array( char )
    derive_set_array( byte )
    derive_set_array( int16 )
    derive_set_array( word16 )
    derive_set_array( int32 )
    derive_set_array( word32 )
    derive_set_array( int64 )
    derive_set_array( word64 )
    derive_set_array( float )
    derive_set_array( double )
  # undef derive_set_array

    array<_auto_<char, M>, M>*      set_array_charstr()
      {
        delete_data();  vxtype = z_array_charstr;
        return new( (array<_auto_<char, M>, M>*)&chdata ) array<_auto_<char, M>, M>();
      }
    array<_auto_<widechar, M>, M>*  set_array_widestr()
      {
        delete_data();  vxtype = z_array_widestr;
        return new( (array<_auto_<widechar, M>, M>*)&chdata ) array<_auto_<widechar, M>, M>();
      }
    array<zmap<M>, M>*            set_array_zmap()
      {
        delete_data();  vxtype = z_array_zmap;
        return new( (array<zmap<M>, M>*)&chdata ) array<zmap<M>, M>();
      }
    array<zval<M>, M>*            set_array_zval()
      {
        delete_data();  vxtype = z_array_zval;
        return new( (array<zval<M>, M>*)&chdata )array<zval<M>, M>();
      }

  protected:  // arithmetic helpers
    template <class A, class B> static  zval  GetMul( A a, B b )  {  return a * b;  }
    template <class A, class B> static  zval  GetDiv( A a, B b )  {  return a / b;  }
    template <class A, class B> static  zval  GetAdd( A a, B b )  {  return a + b;  }
    template <class A, class B> static  zval  GetSub( A a, B b )  {  return a - b;  }

    template <class A, class B> static  zval  GetAnd( A a, B b )  {  return a & b;  }
    template <class A, class B> static  zval  GetXor( A a, B b )  {  return a ^ b;  }
    template <class A, class B> static  zval  Get_Or( A a, B b )  {  return a | b;  }
    template <class A, class B> static  zval  GetPct( A a, B b )  {  return a % b;  }
    template <class A, class B> static  zval  GetShl( A a, B b )  {  return a << b;  }
    template <class A, class B> static  zval  GetShr( A a, B b )  {  return a >> b;  }

    /*
      операции над zval и целым или дробным значением - макрогенерация:
      template <class V> zval  (#)( zval, V )
    */
    # define  derive_operation_zval_value( funcname )                     \
    template <class V>  zval  funcname( V v ) const                       \
      {                                                                     \
        switch ( gettype() )                                                \
        {                                                                   \
          case z_char:    return funcname( *get_char(), v );                \
          case z_byte:    return funcname( *get_byte(), v );                \
          case z_int16:   return funcname( *get_int16(), v );               \
          case z_int32:   return funcname( *get_int32(), v );               \
          case z_int64:   return funcname( *get_int64(), v );               \
          case z_word16:  return funcname( *get_word16(), v );              \
          case z_word32:  return funcname( *get_word32(), v );              \
          case z_word64:  return funcname( *get_word64(), v );              \
          case z_float:   return funcname( *get_float(), v );               \
          case z_double:  return funcname( *get_double(), v );              \
          default:        return zval();                                  \
        }                                                                   \
      }
      derive_operation_zval_value( GetMul )
      derive_operation_zval_value( GetDiv )
      derive_operation_zval_value( GetAdd )
      derive_operation_zval_value( GetSub )
    # undef  derive_operation_zval_value

    /*
      операции над zval и zval - макрогенерация:
      zval  (#)( const zval&, const zval& )
    */
    # define  derive_operation_zval_zval( funcname )                    \
    template <class Z>  zval  funcname( const zval<Z>& x ) const        \
      {                                                                     \
        switch ( x.gettype() )                                              \
        {                                                                   \
          case z_char:    return funcname( *x.get_char() );                 \
          case z_byte:    return funcname( *x.get_byte() );                 \
          case z_int16:   return funcname( *x.get_int16() );                \
          case z_int32:   return funcname( *x.get_int32() );                \
          case z_int64:   return funcname( *x.get_int64() );                \
          case z_word16:  return funcname( *x.get_word16() );               \
          case z_word32:  return funcname( *x.get_word32() );               \
          case z_word64:  return funcname( *x.get_word64() );               \
          case z_float:   return funcname( *x.get_float() );                \
          case z_double:  return funcname( *x.get_double() );               \
          default:        return zval();                                  \
        }                                                                   \
      }
      derive_operation_zval_zval( GetMul )
      derive_operation_zval_zval( GetDiv )
      derive_operation_zval_zval( GetSub )
    # undef derive_operation_zval_zval

    /*
      специализация GetAdd с поддержкой суммирования однотипных строк
    */
    template <class A>
    static  zval  StrCat( A a, const char* b )
      {
        return zval();
      }
    template <class A>
    static  zval  StrCat( A a, const widechar* b )
      {
        return zval();
      }
    static  zval  StrCat( const char* a, const char* b )
      {
        zval  o;

        a = a != nullptr ? a : "";
        b = b != nullptr ? b : "";
        if ( o.set_charstr( nullptr, w_strlen( a ) + w_strlen( b ) ) == nullptr )
          return zval();
        w_strcat( w_strcpy( o.get_charstr(), a ), b );
          return o;
      }
    static  zval  StrCat( const widechar* a, const widechar* b )
      {
        widechar  z = 0;
        zval    o;

        a = a != nullptr ? a : &z;
        b = b != nullptr ? b : &z;
        if ( o.set_widestr( nullptr, w_strlen( a ) + w_strlen( b ) ) == nullptr )
          return zval();
        w_strcat( w_strcpy( o.get_widestr(), a ), b );
          return o;
      }
    static  zval  StrCat( const char*, const widechar* )  {  return zval();  }
    static  zval  StrCat( const widechar*, const char* )  {  return zval();  }

    template <class V>  zval  StrCat( V v ) const
      {
        switch ( gettype() )
        {
          case z_char:    return StrCat( *get_char(),   v );
          case z_byte:    return StrCat( *get_byte(),   v );
          case z_int16:   return StrCat( *get_int16(),  v );
          case z_int32:   return StrCat( *get_int32(),  v );
          case z_int64:   return StrCat( *get_int64(),  v );
          case z_word16:  return StrCat( *get_word16(), v );
          case z_word32:  return StrCat( *get_word32(), v );
          case z_word64:  return StrCat( *get_word64(), v );
          case z_float:   return StrCat( *get_float(),  v );
          case z_double:  return StrCat( *get_double(), v );
          case z_charstr: return StrCat( get_charstr(), v );
          case z_widestr: return StrCat( get_widestr(), v );
          default:        return zval();
        }
      }
    template <class Z>  zval  GetAdd( const zval<Z>& x ) const
      {
        switch ( x.gettype() )
        {
          case z_char:    return GetAdd( *x.get_char() );
          case z_byte:    return GetAdd( *x.get_byte() );
          case z_int16:   return GetAdd( *x.get_int16() );
          case z_int32:   return GetAdd( *x.get_int32() );
          case z_int64:   return GetAdd( *x.get_int64() );
          case z_word16:  return GetAdd( *x.get_word16() );
          case z_word32:  return GetAdd( *x.get_word32() );
          case z_word64:  return GetAdd( *x.get_word64() );
          case z_float:   return GetAdd( *x.get_float() );
          case z_double:  return GetAdd( *x.get_double() );
          case z_charstr: return StrCat( x.get_charstr() );
          case z_widestr: return StrCat( x.get_widestr() );
          default:        return zval();
        }
      }

    /*
      макрогенерация битовых операций над целочисленными значениями
    */
    # define  derive_math( funcname )                                       \
    template <class V>  zval  funcname( V v ) const                       \
      {                                                                     \
        switch ( gettype() )                                                \
        {                                                                   \
          case z_char:    return funcname( *get_char(), v );                \
          case z_byte:    return funcname( *get_byte(), v );                \
          case z_int16:   return funcname( *get_int16(), v );               \
          case z_int32:   return funcname( *get_int32(), v );               \
          case z_int64:   return funcname( *get_int64(), v );               \
          case z_word16:  return funcname( *get_word16(), v );              \
          case z_word32:  return funcname( *get_word32(), v );              \
          case z_word64:  return funcname( *get_word64(), v );              \
          default:        return zval();                                  \
        }                                                                   \
      }                                                                     \
    template <class Z>  zval  funcname( const zval<Z>& x ) const        \
      {                                                                     \
        switch ( x.gettype() )                                              \
        {                                                                   \
          case z_char:    return funcname( *x.get_char() );                 \
          case z_byte:    return funcname( *x.get_byte() );                 \
          case z_int16:   return funcname( *x.get_int16() );                \
          case z_int32:   return funcname( *x.get_int32() );                \
          case z_int64:   return funcname( *x.get_int64() );                \
          case z_word16:  return funcname( *x.get_word16() );               \
          case z_word32:  return funcname( *x.get_word32() );               \
          case z_word64:  return funcname( *x.get_word64() );               \
          default:        return zval();                                  \
        }                                                                   \
      }
      derive_math( GetPct )
      derive_math( GetShl )
      derive_math( GetShr )
      derive_math( GetAnd )
      derive_math( GetXor )
      derive_math( Get_Or )
    # undef derive_math

  public:     // arithmetic
    template <class Z>  zval<M> operator * ( const zval<Z>& r ) const {  return GetMul( r );  }
    template <class Z>  zval<M> operator / ( const zval<Z>& r ) const {  return GetDiv( r );  }
    template <class Z>  zval<M> operator % ( const zval<Z>& r ) const {  return GetPct( r );  }
    template <class Z>  zval<M> operator + ( const zval<Z>& r ) const {  return GetAdd( r );  }
    template <class Z>  zval<M> operator - ( const zval<Z>& r ) const {  return GetSub( r );  }
    template <class Z>  zval<M> operator << ( const zval<Z>& r ) const {  return GetShl( r );  }
    template <class Z>  zval<M> operator >> ( const zval<Z>& r ) const {  return GetShr( r );  }
    template <class Z>  zval<M> operator & ( const zval<Z>& r ) const {  return GetAnd( r );  }
    template <class Z>  zval<M> operator ^ ( const zval<Z>& r ) const {  return GetXor( r );  }
    template <class Z>  zval<M> operator | ( const zval<Z>& r ) const {  return Get_Or( r );  }

  protected:  // compare helpers
    /*
      базовый функционал сравнения:
        <   0x01
        >   0x02
        ==  0x04
        !=  0x08
            0x00 - операция не поддерживается
    */
    template <class A, class B>
    static  int   CompTo( A a, B b )
      {
        int    rc = (a - b > 0) - (a - b < 0);
        return rc < 0 ? 0x01 + 0x08 : rc > 0 ? 0x02 + 0x08 : 0x04;
      }
    # define  derive_strcmp( c1, c2 )                             \
    static int CompTo( const c1* a, const c2* b )                 \
      {                                                           \
        int    rc = w_strcmp( a, b );                             \
        return rc < 0 ? 0x01 + 0x08 : rc > 0 ? 0x02 + 0x08 : 0x04;\
      }
      derive_strcmp( char, char )
      derive_strcmp( char, widechar )
      derive_strcmp( widechar, char )
      derive_strcmp( widechar, widechar )
    # undef derive_strcmp

    # define  derive_noncmp( c1, c2 ) static  int   CompTo( c1, c2 )  {  return 0;  }
      derive_noncmp( const char*, float )
      derive_noncmp( const char*, double )
      derive_noncmp( const widechar*, float )
      derive_noncmp( const widechar*, double )

      derive_noncmp( char, const char* )
      derive_noncmp( byte_t, const char* )
      derive_noncmp( int16_t, const char* )
      derive_noncmp( int32_t, const char* )
      derive_noncmp( int64_t, const char* )
      derive_noncmp( float_t, const char* )
      derive_noncmp( word16_t, const char* )
      derive_noncmp( word32_t, const char* )
      derive_noncmp( word64_t, const char* )
      derive_noncmp( double_t, const char* )

      derive_noncmp( char, const widechar* )
      derive_noncmp( byte_t, const widechar* )
      derive_noncmp( int16_t, const widechar* )
      derive_noncmp( int32_t, const widechar* )
      derive_noncmp( int64_t, const widechar* )
      derive_noncmp( float_t, const widechar* )
      derive_noncmp( word16_t, const widechar* )
      derive_noncmp( word32_t, const widechar* )
      derive_noncmp( word64_t, const widechar* )
      derive_noncmp( double_t, const widechar* )
    # undef derive_noncmp

    template <class B>  int   CompTo( const B& b ) const
      {
        switch ( gettype() )
        {
          case z_char:    return CompTo( *get_char(), b );
          case z_byte:    return CompTo( *get_byte(), b );
          case z_int16:   return CompTo( *get_int16(), b );
          case z_int32:   return CompTo( *get_int32(), b );
          case z_int64:   return CompTo( *get_int64(), b );
          case z_float:   return CompTo( *get_float(), b );
          case z_word16:  return CompTo( *get_word16(), b );
          case z_word32:  return CompTo( *get_word32(), b );
          case z_word64:  return CompTo( *get_word64(), b );
          case z_double:  return CompTo( *get_double(), b );

          case z_charstr: return CompTo( get_charstr(), b );
          case z_widestr: return CompTo( get_widestr(), b );

          case z_array_char:
          case z_array_byte:
          case z_array_int16:
          case z_array_word16:
          case z_array_int32:
          case z_array_word32:
          case z_array_int64:
          case z_array_word64:
          case z_array_float:
          case z_array_double:

          case z_array_charstr:
          case z_array_widestr:
          case z_array_buffer:
          case z_array_zmap:
          case z_array_zval:
          default:  break;
        }
        return 0;
      }
    template <class Z>  int CompTo( const zval<Z>& x ) const
      {
        switch ( x.gettype() )
        {
          case z_char:    return CompTo( *x.get_char() );
          case z_byte:    return CompTo( *x.get_byte() );
          case z_int16:   return CompTo( *x.get_int16() );
          case z_int32:   return CompTo( *x.get_int32() );
          case z_int64:   return CompTo( *x.get_int64() );
          case z_float:   return CompTo( *x.get_float() );
          case z_word16:  return CompTo( *x.get_word16() );
          case z_word32:  return CompTo( *x.get_word32() );
          case z_word64:  return CompTo( *x.get_word64() );
          case z_double:  return CompTo( *x.get_double() );

          case z_charstr: return CompTo( x.get_charstr() );
          case z_widestr: return CompTo( x.get_widestr() );

          case z_array_char:
          case z_array_byte:
          case z_array_int16:
          case z_array_word16:
          case z_array_int32:
          case z_array_word32:
          case z_array_int64:
          case z_array_word64:
          case z_array_float:
          case z_array_double:

          case z_array_charstr:
          case z_array_widestr:
          case z_array_buffer:
          case z_array_zmap:
          case z_array_zval:
          default:  break;
        }
        return 0;
      }

  public:     // compare
    template <class V> bool  operator == ( const V& v ) const { return (CompTo( v ) & 0x04) != 0; }
    template <class V> bool  operator != ( const V& v ) const { return (CompTo( v ) & 0x08) != 0; }
    template <class V> bool  operator < ( const V& v ) const  { return (CompTo( v ) & 0x01) != 0; }
    template <class V> bool  operator > ( const V& v ) const  { return (CompTo( v ) & 0x02) != 0; }
    template <class V> bool  operator <= ( const V& v ) const { return (CompTo( v ) & 0x05) != 0; }
    template <class V> bool  operator >= ( const V& v ) const { return (CompTo( v ) & 0x06) != 0; }

  protected:  // helpers
    void  delete_data()
      {
        switch ( vxtype )
        {
//          case z_buffer:  __safe_array_destruct( (_freebuffer_*)&chdata, 1 ); break;
          case z_charstr:
          case z_widestr: M().free( *(char**)&chdata );                     break;
          case z_zmap:  __safe_array_destruct( (zmap<M>*)&chdata, 1 );  break;

      # define derive_destruct( _type_ )          \
        case  z_array_##_type_: __safe_array_destruct( (array<_type_##_t, M>*)&chdata, 1 );  break;
          derive_destruct( char )
          derive_destruct( byte )
          derive_destruct( int16 )
          derive_destruct( word16 )
          derive_destruct( int32 )
          derive_destruct( word32 )
          derive_destruct( int64 )
          derive_destruct( word64 )
          derive_destruct( float )
          derive_destruct( double )
      # undef derive_destruct

          case z_array_charstr: __safe_array_destruct( (array<_auto_<char, M>, M>*)&chdata, 1 );  break;
          case z_array_widestr: __safe_array_destruct( (array<_auto_<widechar, M>, M>*)&chdata, 1 );  break;
          case z_array_zmap:  __safe_array_destruct( (array<zmap<M>, M>*)&chdata, 1 );  break;
          case z_array_zval:  __safe_array_destruct( (array<zval<M>, M>*)&chdata, 1 );  break;
          default:  break;
        }
        vxtype = 0xff;
      }
  };

  template <class M>
  class zmap
  {
    struct ztree;
    template <class owner, class key> class  zval;

  // private accessors for chain assignments of zval internal class
    template <class R, class K>
    static zval<M>* get_zval( zval<R, K>& r )
      {
        zval<M>*  xv = get_zval( *(R*)&r.parent );
        zmap<M>*  za;
        zval<M>*  pv;

        if ( (za = xv->get_zmap()) == nullptr
          && (za = xv->set_zmap()) == nullptr )  throw zmap_exception( ENOMEM, "Out of memory", __FILE__, __LINE__ );
        if ( (pv = za->get_zval( r.thekey )) == nullptr
          && (pv = za->put_zval( r.thekey )) == nullptr ) throw zmap_exception( ENOMEM, "Out of memory", __FILE__, __LINE__ );
        return pv;
      }
    template <class K>
    static zval<M>* get_zval( zval<zmap<M>, K>& r )
      {
        zval<M>*  pv;
        if ( (pv = ((zmap<M>*)&r.parent)->get_zval( r.thekey )) == nullptr
          && (pv = ((zmap<M>*)&r.parent)->put_zval( r.thekey )) == nullptr ) throw zmap_exception( ENOMEM, "Out of memory", __FILE__, __LINE__ );
        return pv;
      }
    template <class R, class K>
    static const zval<M>* get_zval( const zval<R, K>& r )
      {
        const zval<M>*  xv;
        const zmap<M>*  za;
        return (xv = get_zval( r.parent )) != nullptr && (za = xv->get_zmap()) != nullptr ?
          za->get_zval( r.thekey ) : nullptr;
      }
    template <class K>
    static const zval<M>* get_zval( const zval<zmap<M>, K>& r )
      {
        return r.parent.get_zval( r.thekey );
      }

    template <class owner, class key>
    class  zval
    {
      friend class zmap;

    // construction
      zval( owner& o, key k ): parent( o ), thekey( k ) {}

    public:     // type conversions
    # define derive_operator( _type_ )                                                                    \
      operator _type_##_t () const                                                                        \
        {                                                                                                 \
          const zval<M>*  pv;                                                                           \
          const _type_##_t* pt;                                                                           \
          return (pv = get_zval( *this )) != nullptr && (pt = pv->get_##_type_()) != nullptr ? *pt : 0; \
        }

      derive_operator( char )
      derive_operator( byte )
      derive_operator( int16 )
      derive_operator( int32 )
      derive_operator( int64 )
      derive_operator( word16 )
      derive_operator( word32 )
      derive_operator( word64 )
      derive_operator( float )
      derive_operator( double )
    # undef derive_operator
      operator zmap () const  {  const zval<M>* p;  return (p = get_zval( *this )) != nullptr ? *p->get_zmap() : zmap();  }
      operator const char* () const {  const zval<M>* p;  return (p = get_zval( *this )) != nullptr ? p->get_charstr() : nullptr;  }
      operator const widechar* () const {  const zval<M>* p;  return (p = get_zval( *this )) != nullptr ? p->get_widestr() : nullptr;  }

  /*
    zmap[key].set_xxx

    Поддержка конструкций с явным указанием типизации данных, но с выбрасываемыми исключениями:
      zmap& add = z[1].set_zmap( z )
      int32_t one = z["1"].set_int32( 1 )
      const char* two = z[L"w"].set_charstr( "two" )
  */
    public:     // zmap[key].set_xxx functions
    # define derive_setval( _type_ )                              \
      _type_##_t& set_##_type_( const _type_##_t& t )             \
        {  return *get_zval( *this )->set_##_type_( t );  }

      derive_setval( char )
      derive_setval( byte )
      derive_setval( int16 )
      derive_setval( int32 )
      derive_setval( int64 )
      derive_setval( word16 )
      derive_setval( word32 )
      derive_setval( word64 )
      derive_setval( float )
      derive_setval( double )
    # undef derive_setval
      zmap&     set_zmap( const zmap& z = zmap() )  {  return *get_zval( *this )->set_zmap( z );  }
      const char* set_charstr( const char* s )              {  return get_zval( *this )->set_charstr( s );  }
      const char* set_widestr( const widechar* w )          {  return get_zval( *this )->set_widestr( w );  }

  /*
    zmap[key] = ...

    assignment operators - set typed value with automatic type detection
  */
    public:     // zmap[key] = assignment
      char&           operator = ( char c )             {  return set_char( c );    }
      byte_t&         operator = ( byte_t b )           {  return set_byte( b );    }
      int16_t&        operator = ( int16_t i )          {  return set_int16( i );   }
      int32_t&        operator = ( int32_t i )          {  return set_int32( i );   }
      int64_t&        operator = ( int64_t i )          {  return set_int64( i );   }
      word16_t&       operator = ( word16_t i )         {  return set_word16( i );  }
      word32_t&       operator = ( word32_t i )         {  return set_word32( i );  }
      word64_t&       operator = ( word64_t i )         {  return set_word64( i );  }
      float&          operator = ( float f )            {  return set_float( f );   }
      double&         operator = ( double d )           {  return set_double( d );  }
      zmap&         operator = ( const zmap& z )    {  return set_zmap( z );  }
      const char*     operator = ( const char* s )      {  return set_charstr( s ); }
      const widechar* operator = ( const widechar* w )  {  return set_widestr( w ); }

  /*
    [] operators

    access to assiciative array with defined key
  */
    public:     // [] operators
  # define derive_access_operator( _key_type_ )                               \
    auto operator [] ( _key_type_ k )                      \
      {  return zval<zval, _key_type_>( *this, k );  }                        \
    const auto operator [] ( _key_type_ k ) const          \
      {  return zval<const zval, _key_type_>( *this, k );  }

    derive_access_operator( int )
    derive_access_operator( unsigned )
    derive_access_operator( const char* )
    derive_access_operator( const widechar* )
  # undef derive_access_operator

    protected:
      const owner&  parent;
      key           thekey;

    };

  public:     // high-level API
    # define derive_access_operator( _key_type_ )                         \
    zval<zmap<M>, _key_type_>  operator [] ( _key_type_ k )             \
      {  return zval<zmap<M>, _key_type_>( *this, k );  }               \
    const zval<zmap<M>, _key_type_>  operator [] ( _key_type_ k ) const \
      {  return zval<zmap<M>, _key_type_>( *(zmap<M>*)this, k );  }

    derive_access_operator( unsigned )
    derive_access_operator( const char* )
    derive_access_operator( const widechar* )
  # undef derive_access_operator

  public:     // enumeration support

    class zkey
    {
      friend class  zmap;
      friend struct zmap::ztree;

      const char* keybuf;
      unsigned    keylen;
      unsigned    keyset;

    public:     // constructors
      zkey(): keybuf( nullptr ), keylen( 0 ), keyset( -1 )
        {
        }
      zkey( const zkey& z ): keybuf( z.keybuf ), keylen( z.keylen ), keyset( z.keyset )
        {
        }

    private:    // real initialization constructor
      zkey( const byte_t* k, unsigned l, unsigned t ): keybuf( (const char*)k ), keylen( l ), keyset( t )
        {
        }

    public:     // types
      operator unsigned() const
        {  return keyset == 0 ? zmap_key_to_int( keybuf, keylen ) : 0;  }
      operator const char*() const
        {  return keyset == 1 ? (const char*)keybuf : nullptr;  }
      operator const widechar*() const
        {  return keyset == 2 ? (const widechar*)keybuf : nullptr;  }
    };

  private:    // internal structures
    struct  ztree: public array<ztree, M>
    {
      byte_t    chnode;
      byte_t    keyset;     // the key type
      zval<M> avalue;     // the element value

    public:     // construction
      ztree( byte_t chinit = '\0' ): chnode( chinit ), keyset( 0 )  {}
      ztree( const ztree& z ): chnode( z.chnode ), keyset( z.keyset ) {  assert( z.size() == 0 );  }
     ~ztree()  {}

    public:     // unserialized tree work
      ztree*        insert( const byte_t* ptrkey, unsigned cchkey )
        {
          ztree*  expand = this;

          for ( ; ; ++ptrkey, --cchkey )
          {
            if ( cchkey > 0 )
            {
              byte_t  chnext = *ptrkey;
              ztree*  ptrtop = expand->begin();
              ztree*  ptrend = expand->end();

              while ( ptrtop < ptrend && ptrtop->chnode < chnext )
                ++ptrtop;
              if ( ptrtop >= ptrend || ptrtop->chnode != chnext )
              {
                int   newpos;

                if ( expand->Insert( newpos = (int)(ptrtop - *expand), ztree( chnext ) ) != 0 ) return nullptr;
                  else  ptrtop = *expand + newpos;
              }
              expand = ptrtop;
            }
              else
            return expand;
          }
        }
      const ztree*  search( const byte_t* ptrkey, unsigned cchkey ) const
        {
          if ( cchkey > 0 )
          {
            byte_t        chnext = *ptrkey;
            const ztree*  ptrtop = this->begin();
            const ztree*  ptrend = this->end();

            while ( ptrtop < ptrend && ptrtop->chnode < chnext )
              ++ptrtop;
            if ( ptrtop >= ptrend || ptrtop->chnode != chnext )
              return nullptr;
            return ptrtop->search( ptrkey + 1, cchkey - 1 );
          }
          return this;
        }
      int           lookup( byte_t* keybuf, int keylen, int buflen ) const;

      public:     // enumeration
        template <class A>  int       Enumerate( array<byte_t, M>&, int, A );
        template <class A>  int       Enumerate( A a );

      public:     // serialization
                            unsigned  GetBufLen(    ) const;
        template <class O>  O*        Serialize( O* ) const;
        template <class S>  S*        FetchFrom( S* );

      protected:  // helpers
        int       plain_branchlen() const;
    };

    struct  zdata: public ztree
    {
      int     nitems;
      int     rcount;

    public:     // construction
      zdata():
        ztree(), nitems( 0 ), rcount( 1 ) {}

    };

    struct  zstate
    {
      const ztree*  object;
      const ztree*  ptrtop;
    };

  public:     // construction
    zmap(): zhandler( nullptr )
      {
      }
    zmap( const zmap& z )
      {
        if ( (zhandler = z.zhandler) != nullptr )
          ++zhandler->rcount;
      }
   ~zmap()
      {
        if ( zhandler != nullptr && --zhandler->rcount == 0 )
          M().deallocate( zhandler );
      }
  zmap& operator = ( const zmap& z )
      {
        zdata*  phandler;

        if ( (phandler = z.zhandler) != nullptr )
          ++phandler->rcount;
        if ( zhandler != nullptr && --zhandler->rcount == 0 )
          M().deallocate( zhandler );
        zhandler = phandler;
          return *this;
      }

  protected:  // helpers
    static  byte_t* inc_assign( byte_t* p, byte_t c )
      {
        *p++ = c;  return p;
      }
    zval<M>*  put_zval( const byte_t* p, unsigned l, unsigned k )
      {
        ztree*  pfound;

        if ( zhandler == nullptr && (zhandler = M().template allocate<zdata>()) == nullptr )
          return nullptr;

        if ( (pfound = zhandler->insert( p, l )) != nullptr )  pfound->keyset = k;
          else  return nullptr;

        if ( pfound->avalue.gettype() == 0xff )
          ++zhandler->nitems;

        return &pfound->avalue;
      }

  public:     // put_zval family
    zval<M>*  put_zval( unsigned    ndwkey )
      {
        byte_t  thekey[4];

        return put_zval( thekey, zmap_int_to_key( thekey, ndwkey ), 0 );
      }
    zval<M>*  put_zval( const char*  pszkey )
      {
        return put_zval( (const byte_t*)pszkey, (unsigned)strlen( pszkey ), 1 );
      }
    zval<M>*  put_zval( const widechar*  pszkey )
      {
        return put_zval( (const byte_t*)pszkey, (unsigned)(sizeof(widechar) * w_strlen( pszkey )), 2 );
      }
    zval<M>*  put_zval( const widechar* wszkey, const zval<M>& xv )
      {
        zval<M>*  pv;
        return (pv = put_zval( wszkey )) != nullptr ? &(*pv = xv) : nullptr;
      }
    zval<M>*  put_zval( unsigned    ndwkey, const zval<M>& xv )
      {
        zval<M>*  pv;
        return (pv = put_zval( ndwkey )) != nullptr ? &(*pv = xv) : nullptr;
      }
    zval<M>*  put_zval( const char* pszkey, const zval<M>& xv )
      {
        zval<M>*  pv;
        return (pv = put_zval( pszkey )) != nullptr ? &(*pv = xv) : nullptr;
      }

  protected:  // get_untyped family
    const ztree*  get_untyped( unsigned     ndwkey ) const
      {
        byte_t  thekey[4];

        return zhandler != nullptr ? zhandler->search( thekey, zmap_int_to_key( thekey, ndwkey ) ) : nullptr;
      }
    const ztree*  get_untyped( const char*  pszkey ) const
      {
        return zhandler != NULL ? zhandler->search( (const byte_t*)pszkey,
          (unsigned)strlen( pszkey ) ) : nullptr;
      }
    const ztree*  get_untyped( const widechar*  pszkey ) const
      {
        return zhandler != NULL ? zhandler->search( (const byte_t*)pszkey,
          (unsigned)(sizeof(widechar) * w_strlen( pszkey )) ) : nullptr;
      }
    ztree*  get_untyped( unsigned     thekey )
      {  return (ztree*)((const zmap*)this)->get_untyped( thekey );  }
    ztree*  get_untyped( const char*  thekey )
      {  return (ztree*)((const zmap*)this)->get_untyped( thekey );  }
    ztree*  get_untyped( const widechar*  thekey )
      {  return (ztree*)((const zmap*)this)->get_untyped( thekey );  }

  public:     // get_?
  # define  derive_get_zval( _type_ )                                           \
    const zval<M>* get_zval( _type_ thekey ) const                            \
      {                                                                           \
        const ztree*  zt;                                                         \
        return (zt = get_untyped( thekey )) != nullptr ? &zt->avalue : nullptr;   \
      }                                                                           \
    zval<M>*       get_zval( _type_ thekey )                                  \
      {                                                                           \
        const ztree*  zt;                                                         \
        return (zt = get_untyped( thekey )) != nullptr ? (zval<M>*)&zt->avalue : nullptr;   \
      }
    derive_get_zval( unsigned )
    derive_get_zval( const char* )
    derive_get_zval( const widechar* )
  # undef derive_get_zval

  public:     // access
  # define  derive_access( _type_ )                                                         \
    _type_##_t* set_##_type_( unsigned  k, _type_##_t v = 0 )                                      \
      {                                                                                     \
        zval<M>*  zv;                                                                     \
        return (zv = put_zval( k )) != nullptr ? zv->set_##_type_( v ) : nullptr;         \
      }                                                                                     \
    _type_##_t* set_##_type_( const char* k, _type_##_t v = 0 )                             \
      {                                                                                     \
        zval<M>*  zv;                                                                     \
        return (zv = put_zval( k )) != nullptr ? zv->set_##_type_( v ) : nullptr;         \
      }                                                                                     \
    _type_##_t* set_##_type_( const widechar* k, _type_##_t v = 0 )                         \
      {                                                                                     \
        zval<M>*  zv;                                                                     \
        return (zv = put_zval( k )) != nullptr ? zv->set_##_type_( v ) : nullptr;         \
      }                                                                                     \
    const _type_##_t* get_##_type_( unsigned k ) const                                      \
      {                                                                                     \
        const ztree*  zt;                                                                   \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_##_type_()  : nullptr;   \
      }                                                                                     \
    const _type_##_t* get_##_type_( const char* k ) const                                   \
      {                                                                                     \
        const ztree*  zt;                                                                   \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_##_type_()  : nullptr;   \
      }                                                                                     \
    const _type_##_t* get_##_type_( const widechar* k ) const                               \
      {                                                                                     \
        const ztree*  zt;                                                                   \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_##_type_()  : nullptr;   \
      }                                                                                     \
    _type_##_t* get_##_type_( unsigned k )                                                  \
      {                                                                                     \
        ztree*  zt;                                                                         \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_##_type_()  : nullptr;   \
      }                                                                                     \
    _type_##_t* get_##_type_( const char* k )                                               \
      {                                                                                     \
        ztree*  zt;                                                                         \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_##_type_()  : nullptr;   \
      }                                                                                     \
    _type_##_t* get_##_type_( const widechar* k )                                           \
      {                                                                                     \
        ztree*  zt;                                                                         \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_##_type_()  : nullptr;   \
      }                                                                                     \
    _type_##_t get_##_type_( unsigned k, _type_##_t v ) const                        \
      {                                                                                     \
        const _type_##_t* pval = get_##_type_( k );                                         \
        return pval != nullptr ? *pval : v;                                                 \
      }                                                                                     \
    _type_##_t get_##_type_( const char* k, _type_##_t v ) const                     \
      {                                                                                     \
        const _type_##_t* pval = get_##_type_( k );                                         \
        return pval != nullptr ? *pval : v;                                                 \
      }                                                                                     \
    _type_##_t get_##_type_( const widechar* k, _type_##_t v ) const                 \
      {                                                                                     \
        const _type_##_t* pval = get_##_type_( k );                                         \
        return pval != nullptr ? *pval : v;                                                 \
      }
      derive_access( char )
      derive_access( byte )
      derive_access( int16 )
      derive_access( word16 )
      derive_access( int32 )
      derive_access( word32 )
      derive_access( int64 )
      derive_access( word64 )
      derive_access( float )
      derive_access( double )

//      derive_access( string )
//      derive_access( buffer )

//      derive_access( zval )
  # undef   derive_access

  # define  derive_put_type( k_type, v_type )                                                     \
    v_type* set_##v_type( k_type k )                                                              \
      {                                                                                           \
        zval<M>*  zv;                                                                           \
        return (zv = put_zval( k )) != nullptr ? zv->set_##v_type() : nullptr;                  \
      }                                                                                           \
    v_type* set_##v_type( k_type k, const v_type& z )                                               \
      {                                                                                           \
        zval<M>*  zv;                                                                           \
        return (zv = put_zval( k )) != nullptr ? zv->set_##v_type( z ) : nullptr;               \
      }                                                                                           \
    v_type* get_##v_type( k_type k )                                                                \
      {                                                                                           \
        ztree*  zt;                                                                               \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_##v_type() : nullptr;          \
      }                                                                                           \
    const v_type* get_##v_type( k_type k ) const                                                          \
      {                                                                                           \
        const ztree*  zt;                                                                         \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_##v_type() : nullptr;          \
      }
    derive_put_type( unsigned, zmap )
    derive_put_type( const char*, zmap )
    derive_put_type( const widechar*, zmap )
  # undef derive_put_type

  # define  derive_put_string( k_type, t_name, v_type )                                           \
    v_type* set_##t_name( k_type thekey, const v_type* pszstr, unsigned cchstr = (unsigned)-1 )   \
      {                                                                                           \
        zval<M>* zv;                                                                            \
        return (zv = put_zval( thekey )) != NULL ? zv->set_##t_name( pszstr, cchstr ) : nullptr;\
      }                                                                                           \
    v_type* get_##t_name( k_type thekey )                                                         \
      {                                                                                           \
        ztree*  zt;                                                                               \
        return (zt = get_untyped( thekey )) != NULL ? zt->avalue.get_##t_name()  : NULL;          \
      }                                                                                           \
    const v_type* get_##t_name( k_type thekey, const v_type* defval = nullptr ) const             \
      {                                                                                           \
        const ztree*  zt;                                                                         \
        return (zt = get_untyped( thekey )) != nullptr ? zt->avalue.get_##t_name() : defval;      \
      }
      derive_put_string( unsigned,        charstr, char )
      derive_put_string( const char*,     charstr, char )
      derive_put_string( const widechar*, charstr, char )
      derive_put_string( unsigned,        widestr, widechar )
      derive_put_string( const char*,     widestr, widechar )
      derive_put_string( const widechar*, widestr, widechar )
  # undef derive_put_string

  # define  derive_access( _type_ )                                                         \
    array<_type_##_t, M>* set_array_##_type_( unsigned  k )                                 \
      {                                                                                     \
        zval<M>* zv;                                                                      \
        return (zv = put_zval( k )) != nullptr ? zv->set_array_##_type_() : nullptr;      \
      }                                                                                     \
    array<_type_##_t, M>* set_array_##_type_( const char* k )                                                \
      {                                                                                     \
        zval<M>* zv;                                                                      \
        return (zv = put_zval( k )) != nullptr ? zv->set_array_##_type_() : nullptr;      \
      }                                                                                     \
    array<_type_##_t, M>* set_array_##_type_( const widechar* k )                                            \
      {                                                                                     \
        zval<M>* zv;                                                                      \
        return (zv = put_zval( k )) != nullptr ? zv->set_array_##_type_() : nullptr;      \
      }                                                                                     \
    const array<_type_##_t, M>* get_array_##_type_( unsigned k ) const                                             \
      {                                                                                     \
        const ztree*  zt;                                                                   \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##_type_()  : nullptr;   \
      }                                                                                     \
    const array<_type_##_t, M>* get_array_##_type_( const char* k ) const                                          \
      {                                                                                     \
        const ztree*  zt;                                                                   \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##_type_()  : nullptr;   \
      }                                                                                     \
    const array<_type_##_t, M>* get_array_##_type_( const widechar* k ) const                                      \
      {                                                                                     \
        const ztree*  zt;                                                                   \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##_type_()  : nullptr;   \
      }                                                                                     \
    array<_type_##_t, M>* get_array_##_type_( unsigned k )                                                   \
      {                                                                                     \
        ztree*  zt;                                                                         \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##_type_()  : nullptr;   \
      }                                                                                     \
    array<_type_##_t, M>* get_array_##_type_( const char* k )                                                \
      {                                                                                     \
        ztree*  zt;                                                                         \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##_type_()  : nullptr;   \
      }                                                                                     \
    array<_type_##_t, M>* get_array_##_type_( const widechar* k )                                            \
      {                                                                                     \
        ztree*  zt;                                                                         \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##_type_()  : nullptr;   \
      }

      derive_access( char )
      derive_access( byte )
      derive_access( int16 )
      derive_access( word16 )
      derive_access( int32 )
      derive_access( word32 )
      derive_access( int64 )
      derive_access( word64 )
      derive_access( float )
      derive_access( double )

  # undef derive_access

  # define derive_access_array_str( chtype, fnname, ketype )                                         \
    array<_auto_<chtype, M>, M>* set_array_##fnname( ketype k )                                      \
      {                                                                                              \
        zval<M>*  zv;                                                                              \
        return (zv = put_zval( k )) != nullptr ? zv->set_array_##fnname() : nullptr;               \
      }                                                                                              \
    const array<_auto_<chtype, M>, M>* get_array_##fnname( ketype k ) const                          \
      {                                                                                              \
        const ztree* zt;                                                                             \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##fnname() : nullptr;       \
      }                                                                                              \
    array<_auto_<chtype, M>, M>* get_array_##fnname( ketype k )                                      \
      {                                                                                              \
        ztree* zt;                                                                                   \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##fnname() : nullptr;       \
      }

      derive_access_array_str( char, charstr, unsigned )
      derive_access_array_str( char, charstr, const char* )
      derive_access_array_str( char, charstr, const widechar* )
      derive_access_array_str( widechar, widestr, unsigned )
      derive_access_array_str( widechar, widestr, const char* )
      derive_access_array_str( widechar, widestr, const widechar* )
  # undef derive_access_array_str

//      derive_access( buffer )

  # define derive_access_array_class( cltype, ketype )                                               \
    array<cltype<M>, M>* set_array_##cltype( ketype k )                                              \
      {                                                                                              \
        zval<M>*  zv;                                                                              \
        return (zv = put_zval( k )) != nullptr ? zv->set_array_##cltype() : nullptr;               \
      }                                                                                              \
    const array<cltype<M>, M>* get_array_##cltype( ketype k ) const                                  \
      {                                                                                              \
        const ztree* zt;                                                                             \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##cltype() : nullptr;       \
      }                                                                                              \
    array<cltype<M>, M>* get_array_##cltype( ketype k )                                              \
      {                                                                                              \
        ztree* zt;                                                                                   \
        return (zt = get_untyped( k )) != nullptr ? zt->avalue.get_array_##cltype() : nullptr;       \
      }

      derive_access_array_class( zmap, unsigned )
      derive_access_array_class( zmap, const char* )
      derive_access_array_class( zmap, const widechar* )

      derive_access_array_class( zval, unsigned )
      derive_access_array_class( zval, const char* )
      derive_access_array_class( zval, const widechar* )

  # undef derive_access_array_class
/*
  # define  derive_put_buffer( k_type )                                                           \
    void*  put_buffer( k_type k, unsigned l = 0, const void* p = NULL )                           \
      {                                                                                           \
        zval*   zv;                                                                             \
        return (zv = put_zval( k )) != NULL ? zv->set_buffer( l, p ) : NULL;                    \
      }
    derive_put_buffer( unsigned )
    derive_put_buffer( const char* )
    derive_put_buffer( const widechar* )
  # undef   derive_put_buffer
*/

  public:     // enumeration helpers
    template <class action>
    int       Enumerate( action _do_ )
      {  return zhandler != nullptr ? zhandler->Enumerate( _do_ ) : 0;  }
    template <class action>
    int       Enumerate( action _do_ ) const
      {  return zhandler != nullptr ? zhandler->Enumerate( _do_ ) : 0;  }
    template <class action>
    int       for_each( action _do_ )
      {  return Enumerate( _do_ );  }
    template <class action>
    int       for_each( action _do_ ) const
      {  return Enumerate( _do_ );  }

    int       GetNextKey(       void*     keybuf, int cchkey, int buflen ) const;
    unsigned  GetKeyType( const void*     ptrkey, int cchkey ) const;

    void      DelAllData()
      {
        if ( zhandler != nullptr && --zhandler->rcount == 0 )
          M().deallocate( zhandler );
        zhandler = nullptr;
      }

    int       size() const
      {
        return zhandler != nullptr ? zhandler->nitems : 0;
      }
    int       haskeys() const
      {
        return zhandler != nullptr && zhandler->size() > 0;
      }

  # define  derive_TypeOfData( _type_ )                                                   \
    unsigned  TypeOfData( _type_  thekey ) const                                          \
      {                                                                                     \
        const ztree*  zt;                                                                   \
        return (zt = get_untyped( thekey )) != NULL ? zt->avalue.gettype() : 0xff;        \
      }
    derive_TypeOfData( unsigned )
    derive_TypeOfData( const char* )
    derive_TypeOfData( const widechar* )
  # undef derive_TypeOfData

  public:     // serialization
                        unsigned  GetBufLen(            ) const;
    template <class O>  O*        Serialize( O*  output ) const;
    template <class S>  S*        FetchFrom( S*  source );

  /*
    serial_get_*() methods

    static methods allowing direct access to the field of serialized zmap<> structure

    special fast implementation for 'const char*' source also provided
  */
  protected:  // serial_* helpers
    template <class S>          static  S*  serial_jump_length( S*, unsigned );
    template <class S>          static  S*  serial_skip_zval( S* );
    template <class S>          static  S*  serial_skip_zmap( S* );
    template <class T, class S> static  S*  serial_skip_array_values( S* );
    template <class T, class S> static  S*  serial_skip_array_string( S* );
    template <class S>          static  S*  serial_skip_array_zmap( S* );
    template <class S>          static  S*  serial_skip_array_zval( S* );
    template <class S>          static  S*  serial_get_untyped( S*, const byte_t*, int, char );

    static  const char* serial_jump_length( const char*, unsigned );
    static  const char* serial_skip_zval( const char* );
    static  const char* serial_skip_zmap( const char* );
    static  const char* serial_get_untyped( const char*, const byte_t*, int, char );

  public:     // serial_get_* methods
    template <class S>  static  S*  serial_get_untyped( S*, unsigned );
    template <class S>  static  S*  serial_get_untyped( S*, const char* );
    template <class S>  static  S*  serial_get_untyped( S*, const widechar* );

    template <class S, class Z, class K>
    static  int serial_get_zval( zval<Z>&, S*, K );

  # define derive_get_plain( _type_ ) template <class S, class K>                             \
    static  _type_##_t  serial_get_##_type_( S* s, K k, _type_##_t d = 0 )                    \
    {                                                                                         \
      char        t;                                                                          \
      _type_##_t  v;                                                                          \
      if ( (s = ::FetchFrom( serial_get_untyped( s, k ), t )) == nullptr || t != z_##_type_ ) \
        return d;                                                                             \
      return ::FetchFrom( s, &v, sizeof(v) ) != nullptr ? v : d;                              \
    }
  # define derive_get_smart( _type_ ) template <class S, class K>                             \
    static  _type_##_t  serial_get_##_type_( S* s, K k, _type_##_t d = 0 )                    \
    {                                                                                         \
      char        b;                                                                          \
      _type_##_t  t;                                                                          \
      if ( (s = ::FetchFrom( serial_get_untyped( s, k ), b )) == nullptr || b != z_##_type_ ) \
        return d;                                                                             \
      return ::FetchFrom( s, t ) != nullptr ? t : d;                                          \
    }
    derive_get_plain( char )
    derive_get_plain( byte )
    derive_get_plain( int16 )
    derive_get_plain( word16 )
    derive_get_plain( float )
    derive_get_plain( double )
    derive_get_smart( int32 )
    derive_get_smart( word32 )
    derive_get_smart( int64 )
    derive_get_smart( word64 )

  # undef derive_get_plain
  # undef derive_get_smart

  template <class S, class K>
  static  int   serial_get_string( char* o, unsigned l, S* s, K k )
  {
    unsigned  u;
    byte_t    t;

    if ( (s = ::FetchFrom( serial_get_untyped( s, k ), t )) == nullptr || t != z_charstr )
      return EINVAL;
    if ( (s = ::FetchFrom( s, u )) == nullptr || u >= l )
      return EFAULT;
    if ( (s = ::FetchFrom( s, o, u )) != nullptr )  o[u] = 0;
      else return EFAULT;
    return 0;
  }

  protected:  // variables
    zdata*  zhandler;

  };

}
// serialization helpers

template <class M>
inline  unsigned  GetBufLen( const mtc::zmap<M>& z )
  {
    return z.GetBufLen();
  }
template <class O, class M>
inline  O*        Serialize( O* o, const mtc::zmap<M>& z )
  {
    return z.Serialize( o );
  }
template <class S, class M>
inline  S*        FetchFrom( S* s,       mtc::zmap<M>& z )
  {
    return z.FetchFrom( s );
  }

template <class M>
inline unsigned   GetBufLen( const mtc::array<mtc::zmap<M>, M>& a )
  {
    unsigned  length = ::GetBufLen( a.size() );

    for ( auto p = a.begin(); p < a.end(); ++p )
      length += p->GetBufLen();
    return length;
  }
template <class O, class M>
inline  O*        Serialize( O* o, const mtc::array<mtc::zmap<M>, M>& a )
  {
    if ( (o = ::Serialize( o, a.size() )) != nullptr )
      for ( auto p = a.begin(); p < a.end() && o != nullptr; ++p )
        o = p->Serialize( o );
    return o;
  }
template <class S, class M>
inline  S*        FetchFrom( S* s, mtc::array<mtc::zmap<M>, M>& a )
  {
    int   arsize;

    if ( (s = ::FetchFrom( s, arsize )) == nullptr || a.SetLen( arsize ) != 0 )
      return nullptr;

    for ( auto p = a.begin(); p < a.end(); )
      if ( (s = (p++)->FetchFrom( s )) == nullptr )
        break;
    return s;
  }

template <class M>
inline  unsigned  GetBufLen( const mtc::zval<M>& x )
  {
    return x.GetBufLen();
  }
template <class M, class O>
inline  O*        Serialize( O* o, const mtc::zval<M>& x )
  {
    return x.Serialize( o );
  }
template <class M, class S>
inline  S*        FetchFrom( S* s, mtc::zval<M>& x )
  {
    return x.FetchFrom( s );
  }

template <class M>
inline  unsigned  GetBufLen( const mtc::array<mtc::zval<M>, M>& a )
  {
    unsigned  length = ::GetBufLen( a.size() );

    for ( auto p = a.begin(); p < a.end(); ++p )
      length += p->GetBufLen();
    return length;
  }
template <class O, class M>
inline  O*        Serialize( O* o, const mtc::array<mtc::zval<M>, M>& a )
  {
    if ( (o = ::Serialize( o, a.size() )) != nullptr )
      for ( auto p = a.begin(); p < a.end() && o != nullptr; ++p )
        o = p->Serialize( o );
    return o;
  }
template <class S, class M>
inline  S*        FetchFrom( S* s, mtc::array<mtc::zval<M>, M>& a )
  {
    int   arsize;

    if ( (s = ::FetchFrom( s, arsize )) == nullptr || a.SetLen( arsize ) != 0 )
      return nullptr;

    for ( auto p = a.begin(); p < a.end(); )
      if ( (s = (p++)->FetchFrom( s )) == nullptr )
        break;
    return s;
  }

namespace mtc
{
  // zval inline implementation

  template <class M>
  inline  unsigned  zval<M>::GetBufLen() const
  {
    switch ( vxtype )
    {
  # define derive_size_plain( _type_ )  case z_##_type_: return 1 + sizeof(_type_##_t);
  # define derive_size_smart( _type_ )  case z_##_type_: return 1 + ::GetBufLen( *(_type_##_t*)&chdata );
      derive_size_plain( char )
      derive_size_plain( byte )
      derive_size_plain( int16 )
      derive_size_plain( word16 )
      derive_size_plain( float )
      derive_size_plain( double )
      derive_size_smart( int32 )
      derive_size_smart( word32 )
      derive_size_smart( int64 )
      derive_size_smart( word64 )
  # undef derive_size_smart
  # undef derive_size_plain

      case z_charstr:
        {
          const char* pch = *(const char**)&chdata;
          unsigned    cch = (unsigned)(pch != nullptr ? w_strlen( pch ) : 0);

          return 1 + ::GetBufLen( cch ) + cch;
        }
      case z_widestr:
        {
          const widechar* pws = *(const widechar**)&chdata;
          unsigned        cch = (unsigned)(pws != NULL ? w_strlen( pws ) : 0);

          return 1 + ::GetBufLen( cch ) + cch * sizeof(widechar);
        }
//      case z_buffer:
//        return 1 + ::GetBufLen( get_zbuffer()->GetLength() ) + get_zbuffer()->GetLength();
      case z_zmap:
        return 1 + get_zmap()->GetBufLen();

      case z_array_char:    return 1 + ::GetBufLen( *(array<char_t, M>*)&chdata );
      case z_array_byte:    return 1 + ::GetBufLen( *(array<byte_t, M>*)&chdata );
      case z_array_int16:   return 1 + ::GetBufLen( *(array<int16_t, M>*)&chdata );
      case z_array_word16:  return 1 + ::GetBufLen( *(array<word16_t, M>*)&chdata );
      case z_array_int32:   return 1 + ::GetBufLen( *(array<int32_t, M>*)&chdata );
      case z_array_word32:  return 1 + ::GetBufLen( *(array<word32_t, M>*)&chdata );
      case z_array_int64:   return 1 + ::GetBufLen( *(array<int64_t, M>*)&chdata );
      case z_array_word64:  return 1 + ::GetBufLen( *(array<word64_t, M>*)&chdata );
      case z_array_float:   return 1 + ::GetBufLen( *(array<float_t, M>*)&chdata );
      case z_array_double:  return 1 + ::GetBufLen( *(array<double_t, M>*)&chdata );
      case z_array_charstr:  return 1 + ::GetBufLen( *(array<_auto_<char, M>, M>*)&chdata );
      case z_array_widestr:  return 1 + ::GetBufLen( *(array<_auto_<widechar, M>, M>*)&chdata );
      case z_array_zval:  return 1 + ::GetBufLen( *get_array_zval() );
      case z_array_zmap:  return 1 + ::GetBufLen( *get_array_zmap() );

      default:  return 0;
    }
  }

  template <class M>  template <class O>
  inline  O*  zval<M>::Serialize( O* o ) const
  {
    switch ( gettype() )
    {
  # define derive_put_plain( _type_ )  case z_##_type_: return ::Serialize( ::Serialize( o, vxtype ), &chdata, sizeof(_type_##_t) );
  # define derive_put_smart( _type_ )  case z_##_type_: return ::Serialize( ::Serialize( o, vxtype ), *(_type_##_t*)&chdata );
      derive_put_plain( char )
      derive_put_plain( byte )
      derive_put_plain( int16 )
      derive_put_plain( word16 )
      derive_put_plain( float )
      derive_put_plain( double )
      derive_put_smart( int32 )
      derive_put_smart( word32 )
      derive_put_smart( int64 )
      derive_put_smart( word64 )
  # undef derive_put_smart
  # undef derive_put_plain

      case z_charstr:
        {
          const char* pch = *(const char**)&chdata;
          unsigned    cch = (unsigned)(pch != nullptr ? w_strlen( pch ) : 0);

          return ::Serialize( ::Serialize( ::Serialize( o, vxtype ), cch ), pch, cch );
        }
      case z_widestr:
        {
          const widechar* pws = *(const widechar**)&chdata;
          unsigned        cch = (unsigned)(pws != nullptr ? w_strlen( pws ) : 0);

          return ::Serialize( ::Serialize( ::Serialize( o, vxtype ), cch ), pws, sizeof(widechar) * cch );
        }
/*      case fs_buffer:
        return fsPutBuff( fsPutMemo( fsPutChar( output, vxtype ), get_zbuffer()->GetLength() ),
                                                                  get_zbuffer()->GetBuffer(),
                                                                  get_zbuffer()->GetLength() );*/
      case z_zmap:
        return get_zmap()->Serialize( ::Serialize( o, vxtype ) );

  # define  derive_put_array( _type_ ) case z_array_##_type_: return ::Serialize( ::Serialize( o, vxtype ), *(array<_type_##_t, M>*)&chdata );
      derive_put_array( char )
      derive_put_array( byte )
      derive_put_array( float )
      derive_put_array( double )
      derive_put_array( int16 )
      derive_put_array( word16 )
      derive_put_array( int32 )
      derive_put_array( word32 )
      derive_put_array( int64 )
      derive_put_array( word64 )
  # undef derive_put_array
      case z_array_charstr: return ::Serialize( ::Serialize( o, vxtype ), *(array<_auto_<char, M>, M>*)&chdata );
      case z_array_widestr: return ::Serialize( ::Serialize( o, vxtype ), *(array<_auto_<widechar, M>, M>*)&chdata );
      case z_array_zval: return ::Serialize( ::Serialize( o, vxtype ), *(array<zval<M>, M>*)&chdata );
      case z_array_zmap: return ::Serialize( ::Serialize( o, vxtype ), *(array<zmap<M>, M>*)&chdata );

      default:  return 0;
    }
  }

  template <class M>  template <class S>
  inline  S* zval<M>::FetchFrom( S* s )
  {
    byte_t  intype;

    if ( (s = ::FetchFrom( s, intype )) != nullptr ) delete_data();
      else  return nullptr;

    switch ( intype )
    {
  # define derive_get_plain( _type_ )                                                 \
    case z_##_type_: return ::FetchFrom( s, set_##_type_(), sizeof(_type_##_t) );
  # define derive_get_smart( _type_ )                                                 \
    case z_##_type_: return ::FetchFrom( s, *set_##_type_() );
      derive_get_plain( char )
      derive_get_plain( byte )
      derive_get_plain( int16 )
      derive_get_plain( word16 )
      derive_get_plain( float )
      derive_get_plain( double )
      derive_get_smart( int32 )
      derive_get_smart( word32 )
      derive_get_smart( int64 )
      derive_get_smart( word64 )
  # undef derive_get_smart
  # undef derive_get_plain

      case z_charstr:
        {
          unsigned  cch;
          char*     str;

          return (s = ::FetchFrom( s, cch )) != nullptr && (str = set_charstr( nullptr, cch )) != nullptr ?
            ::FetchFrom( s, str, cch ) : nullptr;
        }
      case z_widestr:
        {
          unsigned  cch;
          widechar* str;

          return (s = ::FetchFrom( s, cch )) != nullptr && (str = set_widestr( nullptr, cch )) != nullptr ?
            ::FetchFrom( s, str, sizeof(widechar) * cch ) : nullptr;
        }

  # define  derive_get_array( _type_ )                                \
    case z_##_type_: return ::FetchFrom( s, *set_##_type_() );
      derive_get_array( zmap )
      derive_get_array( array_char )
      derive_get_array( array_byte )
      derive_get_array( array_float )
      derive_get_array( array_double )
      derive_get_array( array_int16 )
      derive_get_array( array_word16 )
      derive_get_array( array_int32 )
      derive_get_array( array_word32 )
      derive_get_array( array_int64 )
      derive_get_array( array_word64 )
      derive_get_array( array_charstr )
      derive_get_array( array_zmap )
      derive_get_array( array_zval )
  # undef derive_get_array

      default:  return 0;
    }
  }

  // zmap::ztree implementation

  template <class M>
  inline  int zmap<M>::ztree::lookup( byte_t* keybuf, int keylen, int buflen ) const
  {
    const ztree*  ptrtop = this->begin();
    const ztree*  ptrend = this->end();
    int           outlen;

    if ( keylen > 0 )
    {
      while ( ptrtop < ptrend && ptrtop->chnode < *keybuf )
        ++ptrtop;
      if ( ptrtop >= ptrend )
        return -1;
      if ( ptrtop->chnode == keybuf[0] )
      {
        if ( (outlen = ptrtop->lookup( keybuf + 1, keylen - 1, buflen - 1 )) != -1 )
          return 1 + outlen;
        if ( ++ptrtop >= ptrend )
          return -1;
      }
      return 1 + ptrtop->lookup( inc_assign( keybuf, ptrtop->chnode ), 0, buflen - 1 );
    }
    return avalue.gettype() != 0xff ? 0 : ptrtop != NULL ? 1 + ptrtop->lookup( inc_assign( keybuf, ptrtop->chnode ), 0, buflen - 1 ) : -1;
  }

  template <class M>  template <class A>
  inline  int zmap<M>::ztree::Enumerate( array<byte_t, M>& b, int l, A a )
  {
    int   nerror;

  // check if element has the data attached; create the key representation and call
  // enumeration processing function
    if ( avalue.gettype() != 0xff && keyset != (unsigned)-1 )
      if ( (nerror = a( zkey( b.begin(), l, keyset ), avalue )) != 0 )
        return nerror;

  // lookup other elements
    for ( auto p = this->begin(); p < this->end(); ++p )
    {
      if ( l + 1 + sizeof(widechar) >= (unsigned)b.size() )
        if ( b.SetLen( l + 0x100 ) != 0 )
          return ENOMEM;

      b[l + 0] = p->chnode;
      b[l + 1] = 0;
      b[l + 2] = 0;

      if ( (nerror = p->Enumerate( b, l + 1, a )) != 0 )
        return nerror;
    }
    return 0;
  }

  template <class M>  template <class A>
  inline  int zmap<M>::ztree::Enumerate( A a )
  {
    array<byte_t, M> keybuf;

    return Enumerate( keybuf, 0, a );
  }

  template <class M>
  inline  unsigned  zmap<M>::ztree::GetBufLen() const
  {
    int       branch = plain_branchlen();
    word16_t  lstore = (branch > 0 ? 0x0400 + branch : size()) + (avalue.gettype() != 0xff ? 0x0400 : 0);
    unsigned  buflen = ::GetBufLen( lstore );

    if ( avalue.gettype() != 0xff )
      buflen += 1 + avalue.GetBufLen();

    if ( branch > 0 )
    {
      const ztree*  pbeg;

      for ( pbeg = this; pbeg->GetLen() == 1 && pbeg->avalue.gettype() == 0xff; pbeg = *pbeg )
        ++buflen;
      return buflen + pbeg->GetBufLen();
    }
      else
    for ( auto p = this->begin(); p < this->end(); ++p, ++buflen )
    {
      unsigned  sublen = p->GetBufLen();
      buflen += ::GetBufLen( sublen ) + sublen;
    }

    return buflen;
  }

  template <class M>  template <class O>
  inline  O*   zmap<M>::ztree::Serialize( O* o ) const
  {
    int       branch = plain_branchlen();
      assert( branch <= 0x100 );
      assert( size() <= 0x100 );
    word16_t  lstore = (branch > 0 ? 0x0400 + branch : this->size()) + (avalue.gettype() != 0xff ? 0x0200 : 0);

    o = ::Serialize( o, lstore );

    if ( avalue.gettype() != 0xff )
      o = avalue.Serialize( ::Serialize( o, keyset ) );

    if ( branch > 0 )
    {
      const ztree*  pbeg;

      for ( pbeg = *this; pbeg->GetLen() == 1 && pbeg->avalue.gettype() == 0xff; pbeg = *pbeg )
        o = ::Serialize( o, pbeg->chnode );
      o = ::Serialize( o, pbeg->chnode );

      return pbeg->Serialize( o );
    }
      else
    for ( auto p = this->begin(); p < this->end(); ++p )
    {
      unsigned  sublen = p->GetBufLen();

      o = p->Serialize( ::Serialize( ::Serialize( o, p->chnode ), sublen ) );
    }
    return o;
  }

  template <class M>  template <class S>
  inline  S*    zmap<M>::ztree::FetchFrom( S* s )
  {
    word16_t  lfetch;

    if ( (s = ::FetchFrom( s, lfetch )) == nullptr )
      return nullptr;

    if ( (lfetch & 0x0200) != 0 && (s = avalue.FetchFrom( ::FetchFrom( s, (char&)keyset ) )) == nullptr )
      return nullptr;

    if ( (lfetch & 0x0400) != 0 )
    {
      ztree*  pbeg = this;
      int     size = lfetch & 0x1ff;

      while ( size-- > 0 )
      {
        if ( pbeg->SetLen( 1 ) == 0 ) pbeg = *pbeg;
          else  return nullptr;
        if ( (s = ::FetchFrom( s, (char&)pbeg->chnode )) == nullptr )
          return nullptr;
      }

      return pbeg->FetchFrom( s );
    }
      else
    if ( this->SetLen( lfetch & 0x1ff ) == 0 )
    {
      for ( auto p = this->begin(); p < this->end() && s != nullptr; ++p )
      {
        unsigned  sublen;

        s = p->FetchFrom( ::FetchFrom( ::FetchFrom( s, (char&)p->chnode ), sublen ) );
      }
    }
    return s;
  }

  template <class M>
  inline  int   zmap<M>::ztree::plain_branchlen() const
  {
    const ztree*  pbeg;
    int           size = 0;

    for ( size = 0, pbeg = this; pbeg->GetLen() == 1 && pbeg->avalue.gettype() == 0xff; pbeg = *pbeg )
      ++size;
    return size;
  }

  template <class M>
  inline  int zmap<M>::GetNextKey( void* keybuf, int cchkey, int buflen ) const
  {
    if ( zhandler == NULL || cchkey == buflen )
      return (unsigned)-1;
    if ( cchkey >= 0 )
      ((char*)keybuf)[cchkey++] = '\0';
    return zhandler->lookup( (byte_t*)keybuf, cchkey, buflen );
  }

  template <class M>
  inline  unsigned  zmap<M>::GetKeyType( const void* ptrkey, int cchkey ) const
  {
    const ztree*  zvalue = zhandler != NULL ? zhandler->search( (const byte_t*)ptrkey, cchkey ) : NULL;
    return zvalue != NULL ? zvalue->keyset : (unsigned)-1;
  }

  template <class M>
  inline  unsigned  zmap<M>::GetBufLen() const
  {
    return zhandler != NULL ? zhandler->GetBufLen() : 1;
  }

  template <class M>  template <class O>
  inline  O*        zmap<M>::Serialize( O* o ) const
  {
    return zhandler != nullptr ? zhandler->Serialize( o ) : ::Serialize( o, (char)0 );
  }

  template <class M>  template <class S>
  inline  S*        zmap<M>::FetchFrom( S*  s )
  {
    if ( zhandler != nullptr && --zhandler->rcount == 0 )
      M().deallocate( zhandler );
    if ( (zhandler = M().template allocate<zdata>()) == nullptr )
      return nullptr;

    return (S*)zhandler->FetchFrom( s );
  }

  /* serial_* methods section for direct access to fields   */  

  template <class M> template <class S>
  S*  zmap<M>::serial_jump_length( S* s, unsigned l )
  {
    char      slocal[0x100];
    unsigned  cbpart;

    while ( (cbpart = l < sizeof(slocal) ? l : sizeof(slocal)) > 0 )
      if ( (s = ::FetchFrom( s, slocal, cbpart )) != nullptr )  l -= cbpart;
        else return nullptr;
    return s;
  }

  template <class M> template <class S>         
  S*  zmap<M>::serial_skip_zval( S* s )
  {
    char      vatype;
    unsigned  sublen;

    if ( (s = ::FetchFrom( s, vatype )) == nullptr )
      return nullptr;
    switch ( vatype )
    {
    # define  derive_skip_plain( _type_ ) case z_##_type_: return serial_jump_length( s, sizeof(_type_##_t) );
      derive_skip_plain( char )
      derive_skip_plain( byte )
      derive_skip_plain( int16 )
      derive_skip_plain( word16 )
      derive_skip_plain( float )
      derive_skip_plain( double )
    # undef derive_skip_plain

    # define  derive_skip_smart( _type_ ) case z_##_type_: {  _type_##_t  t;  return ::FetchFrom( s, t ); }
      derive_skip_smart( int32 )
      derive_skip_smart( int64 )
      derive_skip_smart( word32 )
      derive_skip_smart( word64 )
    # undef derive_skip_smart

      case z_charstr:
        return (s = ::FetchFrom( s, sublen )) != nullptr ? serial_jump_length( s, sublen ) : nullptr;
      case z_widestr:
        return (s = ::FetchFrom( s, sublen )) != nullptr ? serial_jump_length( s, sizeof(widechar) * sublen ) : nullptr;
//        case z_buffer  = 18,
      case z_zmap:
        return serial_skip_zmap( s );

    # define  derive_skip_array_plain( _type_ ) case z_array_##_type_:  \
        return (s = ::FetchFrom( s, sublen )) != nullptr ? serial_jump_length( s, sublen * sizeof(_type_##_t) ) : nullptr;

      derive_skip_array_plain( char )
      derive_skip_array_plain( byte )
      derive_skip_array_plain( float )
      derive_skip_array_plain( double )
    # undef derive_skip_array_plain

      case z_array_int16:   return serial_skip_array_values<int16_t>( s );
      case z_array_int32:   return serial_skip_array_values<int32_t>( s );
      case z_array_int64:   return serial_skip_array_values<int64_t>( s );
      case z_array_word16:  return serial_skip_array_values<word16_t>( s );
      case z_array_word32:  return serial_skip_array_values<word32_t>( s );
      case z_array_word64:  return serial_skip_array_values<word64_t>( s );

      case z_array_charstr: return serial_skip_array_string<char>( s );
      case z_array_widestr: return serial_skip_array_string<widechar>( s );
//        case z_array_buffer  = 50,
      case z_array_zmap:  return serial_skip_array_zmap( s );
      case z_array_zval:  return serial_skip_array_zval( s );
      default:
        return nullptr;
    }
  }

  template <class M> template <class S>
  S*  zmap<M>::serial_skip_zmap( S* s )
  {
    word16_t  lfetch;
    int       arrlen;

    if ( (s = ::FetchFrom( s, lfetch )) == nullptr )
      return nullptr;

  /*  check if value is stored before other data; either skip or return */
    if ( (lfetch & 0x0200) != 0 )
    {
      char  keyset;

      if ( (s = serial_skip_zval( ::FetchFrom( s, keyset ))) == nullptr )
        return nullptr;
    }

  /*  check if branch is patricia-like: check exact match               */
    if ( (lfetch & 0x0400) != 0 )
      return (s = serial_jump_length( s, lfetch & 0x1ff )) != nullptr ? serial_skip_zmap( s ) : nullptr;

    for ( arrlen = lfetch & 0x1ff; arrlen-- > 0; )
    {
      unsigned  sublen;
      byte_t    chnext;

      if ( (s = ::FetchFrom( ::FetchFrom( s, (char&)chnext ), sublen )) == nullptr )
        return nullptr;
      if ( (s = serial_jump_length( s, sublen )) == nullptr )
        return nullptr;
    }
    return s;
  }

  template <class M> template <class T, class S>
  S*  zmap<M>::serial_skip_array_values( S* s )
  {
    int   nitems;
    T     itnext;

    if ( (s = ::FetchFrom( s, nitems )) == nullptr )
      return nullptr;
    while ( nitems-- > 0 && (s = ::FetchFrom( s, itnext )) != nullptr )
      (void)0;
    return s;
  }

  template <class M> template <class T, class S>
  S*  zmap<M>::serial_skip_array_string( S* s )
  {
    int       nitems;
    unsigned  itelen;

    if ( (s = ::FetchFrom( s, nitems )) == nullptr )
      return nullptr;
    while ( nitems-- > 0 && (s = ::FetchFrom( s, itelen )) != nullptr && (s = serial_jump_length( s, sizeof(T) * itelen )) != nullptr )
      (void)0;
    return s;
  }

  template <class M> template <class S>
  S*  zmap<M>::serial_skip_array_zmap( S* s )
  {
    int       nitems;
    unsigned  itelen;

    if ( (s = ::FetchFrom( s, nitems )) == nullptr )
      return nullptr;
    while ( nitems-- > 0 && (s = ::FetchFrom( s, itelen )) != nullptr && (s = serial_skip_zmap( s )) != nullptr )
      (void)0;
    return s;
  }

  template <class M> template <class S>
  S*  zmap<M>::serial_skip_array_zval( S* s )
  {
    int       nitems;
    unsigned  itelen;

    if ( (s = ::FetchFrom( s, nitems )) == nullptr )
      return nullptr;
    while ( nitems-- > 0 && (s = ::FetchFrom( s, itelen )) != nullptr && (s = serial_skip_zval( s )) != nullptr )
      (void)0;
    return s;
  }

  template <class M> template <class S>
  S*  zmap<M>::serial_get_untyped( S* s, const byte_t* k, int l, char t )
  {
    word16_t  lfetch;

    if ( (s = ::FetchFrom( s, lfetch )) == nullptr )
      return nullptr;

  /*  check if value is stored before other data; either skip or return */
    if ( (lfetch & 0x0200) != 0 )
    {
      char  keyset;

      if ( (s = ::FetchFrom( s, keyset )) == nullptr )
        return nullptr;
      if ( l == 0 ) return keyset == t ? s : nullptr;
        else s = skip_zval( s );
    }
      else
    if ( l == 0 )
      return nullptr;

  /*  check if branch is patricia-like: check exact match               */
    if ( (lfetch & 0x0400) != 0 )
    {
      int     patlen = lfetch & 0x1ff;
      byte_t  chload;

      while ( patlen-- > 0 && l > 0 )
      {
        if ( (s = ::FetchFrom( s, (char&)chload )) != nullptr && chload == *k++ ) --l;
          else return nullptr;
      }

      return patlen < 0 ? serial_get_untyped( s, k, l, t ) : nullptr;
    }
      else
    {
      int     arrlen = lfetch & 0x1ff;
      byte_t  chfind = *k++;

      while ( arrlen-- > 0 )
      {
        unsigned  sublen;
        byte_t    chnext;

        if ( (s = ::FetchFrom( ::FetchFrom( s, (char&)chnext ), sublen )) == nullptr )
          return nullptr;

        if ( chfind == chnext ) return serial_get_untyped( s, k, l - 1, t );
          else
        if ( chfind <  chnext ) return nullptr;
          else
        if ( (s = skip_buffer( s, sublen )) == nullptr )
          return nullptr;
      }
      return nullptr;
    }
  }

  template <class M>
  const char* zmap<M>::serial_jump_length( const char* s, unsigned l )
  {
    return s + l;
  }

  template <class M>
  const char* zmap<M>::serial_skip_zval( const char* s )
  {
    char      vatype = *s++;
    unsigned  sublen;

    switch ( vatype )
    {
      case z_char:    return s + sizeof(char);
      case z_byte:    return s + sizeof(byte_t);
      case z_int16:   return s + sizeof(int16_t);
      case z_word16:  return s + sizeof(word16_t);
      case z_float:   return s + sizeof(float);
      case z_double:  return s + sizeof(double);

      case z_int32:
      case z_int64:
      case z_word32:
      case z_word64:  while ( *s++ & 0x80 ) (void)0;  return s;

      case z_charstr: return ::FetchFrom( s, sublen ) + sublen;
      case z_widestr: return ::FetchFrom( s, sublen ) + sizeof(widechar) * sublen;
//        case z_buffer  = 18,
      case z_zmap:  return serial_skip_zmap( s );

      case z_array_char:    return ::FetchFrom( s, sublen ) + sublen;
      case z_array_byte:    return ::FetchFrom( s, sublen ) + sublen;
      case z_array_float:   return ::FetchFrom( s, sublen ) + sublen * sizeof(float);
      case z_array_double:  return ::FetchFrom( s, sublen ) + sublen * sizeof(double);

      case z_array_int16:   return serial_skip_array_values<int16_t>( s );
      case z_array_int32:   return serial_skip_array_values<int32_t>( s );
      case z_array_int64:   return serial_skip_array_values<int64_t>( s );
      case z_array_word16:  return serial_skip_array_values<word16_t>( s );
      case z_array_word32:  return serial_skip_array_values<word32_t>( s );
      case z_array_word64:  return serial_skip_array_values<word64_t>( s );

      case z_array_charstr: return serial_skip_array_string<char>( s );
      case z_array_widestr: return serial_skip_array_string<widechar>( s );
//        case z_array_buffer  = 50,
      case z_array_zmap:  return serial_skip_array_zmap( s );
      case z_array_zval:  return serial_skip_array_zval( s );
      default:
        return nullptr;
    }
  }

  template <class M>
  const char* zmap<M>::serial_skip_zmap( const char* s )
  {
    word16_t  lfetch;
    unsigned  sublen;
    int       arrlen;

    if ( (lfetch = (byte_t)*s++) & 0x80 )
      lfetch = (lfetch & 0x7f) | (((word16_t)(byte_t)*s++) << 7);

  /*  check if value is stored before other data; either skip or return */
    if ( (lfetch & 0x0200) != 0 )
      s = serial_skip_zval( ++s );

  /*  check if branch is patricia-like: check exact match               */
    if ( (lfetch & 0x0400) != 0 )
      return serial_skip_zmap( s + (lfetch & 0x1ff) );

    for ( arrlen = lfetch & 0x1ff; arrlen-- > 0; )
      s = ::FetchFrom( ++s, sublen ) + sublen;

    return s;
  }

  template <class M>
  const char* zmap<M>::serial_get_untyped( const char* s, const byte_t* k, int l, char t )
  {
    word16_t  lfetch;

    if ( (lfetch = (byte_t)*s++) & 0x80 )
      lfetch = (lfetch & 0x7f) | (((word16_t)(byte_t)*s++) << 7);

  /*  check if value is stored before other data; either skip or return */
    if ( (lfetch & 0x0200) != 0 )
    {
      if ( l == 0 ) return *s++ == t ? s : nullptr;
        else s = serial_skip_zval( ++s );
    }
      else
    if ( l == 0 )
      return nullptr;

  /*  check if branch is patricia-like: check exact match               */
    if ( (lfetch & 0x0400) != 0 )
    {
      int     patlen = lfetch & 0x1ff;

      if ( (l -= patlen) < 0 )
        return nullptr;
      while ( patlen-- > 0 )
        if ( *s++ != *k++ ) return nullptr; 

      return serial_get_untyped( s, k, l, t );
    }
      else
    {
      int     arrlen = lfetch & 0x1ff;
      byte_t  chfind = *k++;

      while ( arrlen-- > 0 )
      {
        unsigned  sublen;
        byte_t    chnext;

        if ( (chnext = (byte_t)*s++) == chfind )
        {
          while ( (*s++ & 0x80) != 0 )
            (void)NULL;
          return serial_get_untyped( s, k, l - 1, t );
        }
          else
        if ( chnext > chfind )
          return nullptr;
        s = ::FetchFrom( s, sublen ) + sublen;
      }
      return nullptr;
    }
  }

  template <class M> template <class S>
  S*  zmap<M>::serial_get_untyped( S* s, unsigned k )
  {
    byte_t  thekey[4];

    return serial_get_untyped( s, thekey, zmap_int_to_key( thekey, k ), 0 );
  }

  template <class M> template <class S>
  S*  zmap<M>::serial_get_untyped( S* s, const char* k )
  {
    return serial_get_untyped( s, (const byte_t*)k, w_strlen( k ), 1 );
  }

  template <class M> template <class S>
  S*  zmap<M>::serial_get_untyped( S* s, const widechar* k )
  {
    return serial_get_untyped( s, (const byte_t*)k, sizeof(widechar) * w_strlen( k ), 2 );
  }

  template <class M> template <class S, class Z, class K>
  int zmap<M>::serial_get_zval( zval<Z>& z, S* s, K k )
  {
    return (s = serial_get_untyped( s, k )) != nullptr ? z.FetchFrom( s ) != nullptr ? 0 : EFAULT : ENOENT;
  }

}

# if defined( _MSC_VER )
#   pragma warning( pop )
# endif  // _MSC_VER

# endif  // __zmap_h__ --!>

</body>
</html>